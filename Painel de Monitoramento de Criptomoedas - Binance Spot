import customtkinter as ctk
import ccxt
import pandas as pd
import threading
import time
from collections import deque

# --- Configurações da Interface Gráfica ---
ctk.set_appearance_mode("dark")
ctk.set_default_color_theme("blue")


class PainelMonitoramento(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title("Painel de Monitoramento Automático - Binance Spot")
        self.geometry("1100x700")

        # --- Frame Principal ---
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # --- Frame de Controles ---
        control_frame = ctk.CTkFrame(main_frame)
        control_frame.pack(fill="x", pady=(0, 5))

        # <-- MODIFICADO: Define "5m" como o valor padrão
        self.tf_var = ctk.StringVar(value="5m")
        ctk.CTkLabel(control_frame, text="Timeframe:").pack(side="left", padx=10, pady=10)
        tf_option = ctk.CTkOptionMenu(control_frame, values=["5m", "15m", "30m", "1h", "2h"], variable=self.tf_var)
        tf_option.pack(side="left", padx=0, pady=10)

        self.start_button = ctk.CTkButton(control_frame, text="Iniciar Monitoramento", command=self.iniciar)
        self.start_button.pack(side="left", padx=20, pady=10)

        self.status_label = ctk.CTkLabel(control_frame, text="Pronto para iniciar.", text_color="gray")
        self.status_label.pack(side="right", padx=10, pady=10)

        # --- Frame da Tabela de Resultados ---
        table_container = ctk.CTkFrame(main_frame)
        table_container.pack(fill="both", expand=True)

        # Cabeçalho fixo da tabela
        self.headers = ["Ativo", "Preço", "RSI", "MM20", "MACD > Sinal", "Entrada Média (1h)", "Status"]
        header_frame = ctk.CTkFrame(table_container)
        header_frame.pack(fill="x")
        for i, h in enumerate(self.headers):
            # Aumenta a largura da coluna de Status
            width = 180 if h == "Status" else 100
            lbl = ctk.CTkLabel(header_frame, text=h, font=ctk.CTkFont(weight="bold"))
            lbl.pack(side="left", padx=2, pady=5, expand=True)

        # Frame rolável para as linhas de dados
        self.table_frame = ctk.CTkScrollableFrame(table_container, label_text="Ativos com Potencial")
        self.table_frame.pack(fill="both", expand=True)

        # --- Variáveis de Controle ---
        self.running = False
        self.exchange = ccxt.binance({"enableRateLimit": True, 'options': {'defaultType': 'spot'}})
        self.target_symbols = []
        # Limita a 50 linhas para não sobrecarregar a GUI, mostrando apenas as mais recentes
        self.max_rows = 50
        self.row_widgets = deque()

    def update_status(self, message, color="gray"):
        """Atualiza a label de status de forma segura entre threads."""

        def do_update():
            self.status_label.configure(text=message, text_color=color)

        self.after(0, do_update)

    def adicionar_linha_tabela(self, values):
        """Adiciona uma nova linha à tabela e gerencia o limite de linhas."""

        def do_add():
            # Remove a linha mais antiga se o limite for atingido
            if len(self.row_widgets) >= self.max_rows:
                old_row = self.row_widgets.popleft()
                old_row.destroy()

            row_frame = ctk.CTkFrame(self.table_frame)
            row_frame.pack(fill="x", pady=2, padx=2)

            for i, v in enumerate(values):
                # Lógica de largura
                header = self.headers[i]
                if header == "Status":
                    width = 180
                elif header == "Entrada Média (1h)":
                    width = 140
                else:
                    width = 100

                lbl = ctk.CTkLabel(row_frame, text=v, text_color="lightgreen", width=width)
                lbl.pack(side="left", padx=2, expand=True)

            # Adiciona a nova linha à fila para controle
            self.row_widgets.append(row_frame)

        self.after(0, do_add)

    def limpar_tabela(self):
        """Limpa todas as linhas da tabela."""

        def do_clear():
            while self.row_widgets:
                widget = self.row_widgets.popleft()
                widget.destroy()

        self.after(0, do_clear)

    def carregar_mercados(self):
        """Busca todos os pares de negociação spot da Binance."""
        try:
            self.update_status("Carregando mercados da Binance...", "yellow")
            markets = self.exchange.load_markets()
            self.target_symbols = [
                m['symbol'] for m in markets.values()
                if m['spot'] and m['active'] and (m['symbol'].endswith('/USDT') or m['symbol'].endswith('/BUSD'))
                   and not any(x in m['symbol'] for x in ['UP/', 'DOWN/', 'BULL/', 'BEAR/'])
            ]
            self.update_status(f"{len(self.target_symbols)} mercados spot encontrados.", "white")
            time.sleep(2)  # Pausa para o usuário ler a mensagem
        except Exception as e:
            self.update_status(f"Erro ao carregar mercados: {e}", "red")
            self.target_symbols = []

    def iniciar(self):
        """Inicia o processo de monitoramento em uma thread separada."""
        if not self.running:
            self.running = True
            self.start_button.configure(state="disabled", text="Monitorando...")
            threading.Thread(target=self.loop_monitoramento, daemon=True).start()

    def loop_monitoramento(self):
        """Loop principal que executa a análise continuamente."""
        self.carregar_mercados()
        if not self.target_symbols:
            self.running = False
            self.start_button.configure(state="normal", text="Iniciar Monitoramento")
            return

        while self.running:
            self.atualizar_tabela()

            # <-- MODIFICADO: Mensagem de status atualizada
            self.update_status(f"Análise concluída. Próxima em 5 minutos.", "gray")

            # <-- MODIFICADO: Atualiza a cada 5 minutos (300 segundos)
            time.sleep(300)

    def atualizar_tabela(self):
        """Busca dados, calcula indicadores e atualiza a interface."""
        self.limpar_tabela()
        timeframe = self.tf_var.get()
        total = len(self.target_symbols)

        for i, symbol in enumerate(self.target_symbols):
            if not self.running:
                break

            self.update_status(f"Analisando {i + 1}/{total}: {symbol}", "cyan")
            try:

                # --- FILTRO DE VOLUME 24h (Volatilidade/Liquidez) ---
                ticker = self.exchange.fetch_ticker(symbol)
                volume_24h = ticker.get('quoteVolume')

                if not volume_24h or volume_24h < 5000000:
                    continue
                    # --- FIM DO FILTRO ---

                # 1. Busca dados do TIMEFRAME SELECIONADO (para indicadores)
                ohlcv = self.exchange.fetch_ohlcv(symbol, timeframe, limit=50)
                if len(ohlcv) < 30: continue

                df = pd.DataFrame(ohlcv, columns=["timestamp", "open", "high", "low", "close", "volume"])

                # --- Cálculos dos Indicadores (baseados no timeframe selecionado) ---
                delta = df['close'].diff()
                gain = delta.clip(lower=0).ewm(com=5, adjust=False).mean()
                loss = -delta.clip(upper=0).ewm(com=13, adjust=False).mean()
                rs = gain / loss
                df['rsi'] = 100 - (100 / (1 + rs))

                df['ma20'] = df['close'].rolling(20).mean()

                ema12 = df['close'].ewm(span=12, adjust=False).mean()
                ema26 = df['close'].ewm(span=26, adjust=False).mean()
                df['macd'] = ema12 - ema26
                df['macd_signal'] = df['macd'].ewm(span=9, adjust=False).mean()

                last = df.iloc[-1]
                price_now = last['close']
                rsi_val = last['rsi']
                ma20_val = last['ma20']
                macd_val = last['macd']
                macd_signal_val = last['macd_signal']

                # --- Lógica de Decisão ---
                if (50 <= rsi_val <= 60 and
                        price_now > ma20_val and
                        macd_val > macd_signal_val):

                    try:
                        # 2. Busca dados de 5m (12 velas = 1 hora)
                        ohlcv_5m_data = self.exchange.fetch_ohlcv(symbol, '5m', limit=12)

                        if len(ohlcv_5m_data) < 2:
                            continue

                        df_5m = pd.DataFrame(ohlcv_5m_data,
                                             columns=["timestamp", "open", "high", "low", "close", "volume"])

                        # --- CÁLCULO DO PREÇO DE ENTRADA ---
                        max_1h = df_5m['high'].max()
                        min_1h = df_5m['low'].min()

                        if min_1h <= 0 or max_1h <= 0 or min_1h >= max_1h:
                            continue

                        entrada_media = (max_1h + min_1h) / 2

                        status = "✅ Tendência de Alta / Scalp"

                        values = [
                            symbol, f"{price_now:.6f}", f"{rsi_val:.2f}", f"{ma20_val:.2f}",
                            "Sim", f"{entrada_media:.6f}", status
                        ]
                        self.adicionar_linha_tabela(values)

                    except Exception as e_1h:
                        pass

            except ccxt.NetworkError as e:
                self.update_status(f"Erro de rede com {symbol}: {e}", "orange")
                time.sleep(5)
            except Exception as e:
                pass


if __name__ == "__main__":
    app = PainelMonitoramento()
    app.mainloop()
